[{"/Users/ryanfoley/sei/projects/portfolio/src/index.js":"1","/Users/ryanfoley/sei/projects/portfolio/src/reportWebVitals.js":"2","/Users/ryanfoley/sei/projects/portfolio/src/components/App/App.js":"3","/Users/ryanfoley/sei/projects/portfolio/src/components/Chess/Chess.js":"4","/Users/ryanfoley/sei/projects/portfolio/src/components/Chess/pieces.js":"5","/Users/ryanfoley/sei/projects/portfolio/src/components/Chess/players.js":"6","/Users/ryanfoley/sei/projects/portfolio/src/components/Chess/board.js":"7","/Users/ryanfoley/sei/projects/portfolio/src/components/Nav/Nav.js":"8","/Users/ryanfoley/sei/projects/portfolio/src/components/About/About.js":"9","/Users/ryanfoley/sei/projects/portfolio/src/components/Projects/Projects.js":"10"},{"size":503,"mtime":1608595792264,"results":"11","hashOfConfig":"12"},{"size":362,"mtime":1607627420864,"results":"13","hashOfConfig":"12"},{"size":324,"mtime":1608598863175,"results":"14","hashOfConfig":"12"},{"size":5138,"mtime":1607657514459,"results":"15","hashOfConfig":"12"},{"size":16715,"mtime":1607657434329,"results":"16","hashOfConfig":"12"},{"size":3816,"mtime":1607658593810,"results":"17","hashOfConfig":"12"},{"size":4032,"mtime":1607657414581,"results":"18","hashOfConfig":"12"},{"size":428,"mtime":1608511333679,"results":"19","hashOfConfig":"12"},{"size":1228,"mtime":1608600931670,"results":"20","hashOfConfig":"12"},{"size":2004,"mtime":1608600535494,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1jjrvzr",{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"29","messages":"30","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"32"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35","usedDeprecatedRules":"32"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/ryanfoley/sei/projects/portfolio/src/index.js",[],"/Users/ryanfoley/sei/projects/portfolio/src/reportWebVitals.js",[],["46","47"],"/Users/ryanfoley/sei/projects/portfolio/src/components/App/App.js",[],"/Users/ryanfoley/sei/projects/portfolio/src/components/Chess/Chess.js",["48","49"],"import React from 'react'\nimport { Board, chessBoard } from './board.js'\nimport { placePiecesOnBoard } from './pieces.js'\nimport { whitePlayer, blackPlayer } from './players.js'\nimport './Chess.css'\n\nconst Chess = () => {\n\tlet startGame = false\n\n\tlet squareSelected = false\n\n\t// Start Button\n\tconst startGameButton = document.querySelector('#start-game')\n\n\t// Grab squares\n\tconst squares = document.querySelector('.board')\n\n\t// Grab check display\n\tconst check = document.querySelector('.check-text')\n\n\tlet turn = 'white'\n\tlet selectedPiece\n\tlet landingSquare\n\tlet validMove\n\n\t// Listen for Start-Game event\n\tstartGameButton.addEventListener('click', () => {\n\t\tchessBoard.clearBoard()\n\t\tplacePiecesOnBoard(chessBoard)\n\t\tchessBoard.displayPieces()\n\n\t\tstartGame = true\n\n\t\t// Get position of kings on board\n\t\twhitePlayer.getKingsPosition()\n\t\tblackPlayer.getKingsPosition()\n\t})\n\n\t// Listen for cell clicks\n\tsquares.addEventListener('click', (event) => {\n\t\tconst player = turn === 'white' ? whitePlayer : blackPlayer\n\t\tconst opponent = turn === 'white' ? blackPlayer : whitePlayer\n\t\tBoard.player = turn === 'white' ? whitePlayer : blackPlayer\n\t\tBoard.opponent = turn === 'white' ? blackPlayer : whitePlayer\n\t\tplayer.chessBoard = chessBoard\n\n\t\tif (startGame) {\n\t\t\tif (!selectedPiece) {\n\t\t\t\tconst selectedSquare = chessBoard.selectSquare(event.path)\n\n\t\t\t\t// Check if a piece was selected and it's their turn\n\t\t\t\tif (selectedSquare.color === turn) {\n\t\t\t\t\tselectedPiece = selectedSquare.piece\n\t\t\t\t}\n\t\t\t} else if (!validMove) {\n\t\t\t\tlandingSquare = chessBoard.selectSquare(event.path)\n\n\t\t\t\t// Check the timing on this code\n\t\t\t\tvalidMove = selectedPiece.checkForValidMove(\n\t\t\t\t\tplayer,\n\t\t\t\t\tchessBoard,\n\t\t\t\t\tlandingSquare\n\t\t\t\t)\n\n\t\t\t\t// Get available moves\n\t\t\t\t// player.getAvailableMoves(chessBoard)\n\n\t\t\t\tif (validMove) {\n\t\t\t\t\t// Check if king is in check\n\n\t\t\t\t\t// Mark enemy squares\n\t\t\t\t\tchessBoard.markEnemySquares(whitePlayer, blackPlayer)\n\n\t\t\t\t\tselectedPiece.movePiece(chessBoard.board, landingSquare, opponent)\n\t\t\t\t\tchessBoard.displayPieces()\n\n\t\t\t\t\t// Mark enemy squares\n\t\t\t\t\tchessBoard.markEnemySquares(whitePlayer, blackPlayer)\n\n\t\t\t\t\tplayer.isKingInCheck(chessBoard)\n\t\t\t\t\topponent.isKingInCheck(chessBoard)\n\n\t\t\t\t\tif (player.inCheck || opponent.inCheck) {\n\t\t\t\t\t\tcheck.innerHTML = 'CHECK!'\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcheck.innerHTML = ''\n\t\t\t\t\t}\n\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t'player',\n\t\t\t\t\t\tplayer.checkMate,\n\t\t\t\t\t\t'opponent',\n\t\t\t\t\t\topponent.checkMate\n\t\t\t\t\t)\n\n\t\t\t\t\t// Reset turn variables\n\t\t\t\t\tselectedPiece = false\n\t\t\t\t\tvalidMove = false\n\t\t\t\t\tturn = turn === 'white' ? 'black' : 'white'\n\t\t\t\t} else selectedPiece = null\n\t\t\t}\n\t\t}\n\t})\n\n\treturn (\n\t\t<div class='container'>\n\t\t\t<header>\n\t\t\t\t<h1>Chess</h1>\n\t\t\t\t<div id='start-game'></div>\n\t\t\t</header>\n\t\t\t<div class='board'>\n\t\t\t\t<div class='row-0 col-0'></div>\n\t\t\t\t<div class='row-0 col-1'></div>\n\t\t\t\t<div class='row-0 col-2'></div>\n\t\t\t\t<div class='row-0 col-3'></div>\n\t\t\t\t<div class='row-0 col-4'></div>\n\t\t\t\t<div class='row-0 col-5'></div>\n\t\t\t\t<div class='row-0 col-6'></div>\n\t\t\t\t<div class='row-0 col-7'></div>\n\n\t\t\t\t<div class='row-1 col-0'></div>\n\t\t\t\t<div class='row-1 col-1'></div>\n\t\t\t\t<div class='row-1 col-2'></div>\n\t\t\t\t<div class='row-1 col-3'></div>\n\t\t\t\t<div class='row-1 col-4'></div>\n\t\t\t\t<div class='row-1 col-5'></div>\n\t\t\t\t<div class='row-1 col-6'></div>\n\t\t\t\t<div class='row-1 col-7'></div>\n\n\t\t\t\t<div class='row-2 col-0'></div>\n\t\t\t\t<div class='row-2 col-1'></div>\n\t\t\t\t<div class='row-2 col-2'></div>\n\t\t\t\t<div class='row-2 col-3'></div>\n\t\t\t\t<div class='row-2 col-4'></div>\n\t\t\t\t<div class='row-2 col-5'></div>\n\t\t\t\t<div class='row-2 col-6'></div>\n\t\t\t\t<div class='row-2 col-7'></div>\n\n\t\t\t\t<div class='row-3 col-0'></div>\n\t\t\t\t<div class='row-3 col-1'></div>\n\t\t\t\t<div class='row-3 col-2'></div>\n\t\t\t\t<div class='row-3 col-3'></div>\n\t\t\t\t<div class='row-3 col-4'></div>\n\t\t\t\t<div class='row-3 col-5'></div>\n\t\t\t\t<div class='row-3 col-6'></div>\n\t\t\t\t<div class='row-3 col-7'></div>\n\n\t\t\t\t<div class='row-4 col-0'></div>\n\t\t\t\t<div class='row-4 col-1'></div>\n\t\t\t\t<div class='row-4 col-2'></div>\n\t\t\t\t<div class='row-4 col-3'></div>\n\t\t\t\t<div class='row-4 col-4'></div>\n\t\t\t\t<div class='row-4 col-5'></div>\n\t\t\t\t<div class='row-4 col-6'></div>\n\t\t\t\t<div class='row-4 col-7'></div>\n\n\t\t\t\t<div class='row-5 col-0'></div>\n\t\t\t\t<div class='row-5 col-1'></div>\n\t\t\t\t<div class='row-5 col-2'></div>\n\t\t\t\t<div class='row-5 col-3'></div>\n\t\t\t\t<div class='row-5 col-4'></div>\n\t\t\t\t<div class='row-5 col-5'></div>\n\t\t\t\t<div class='row-5 col-6'></div>\n\t\t\t\t<div class='row-5 col-7'></div>\n\n\t\t\t\t<div class='row-6 col-0'></div>\n\t\t\t\t<div class='row-6 col-1'></div>\n\t\t\t\t<div class='row-6 col-2'></div>\n\t\t\t\t<div class='row-6 col-3'></div>\n\t\t\t\t<div class='row-6 col-4'></div>\n\t\t\t\t<div class='row-6 col-5'></div>\n\t\t\t\t<div class='row-6 col-6'></div>\n\t\t\t\t<div class='row-6 col-7'></div>\n\n\t\t\t\t<div class='row-7 col-0'></div>\n\t\t\t\t<div class='row-7 col-1'></div>\n\t\t\t\t<div class='row-7 col-2'></div>\n\t\t\t\t<div class='row-7 col-3'></div>\n\t\t\t\t<div class='row-7 col-4'></div>\n\t\t\t\t<div class='row-7 col-5'></div>\n\t\t\t\t<div class='row-7 col-6'></div>\n\t\t\t\t<div class='row-7 col-7'></div>\n\t\t\t</div>\n\t\t\t<h2 class='check-text'></h2>\n\t\t</div>\n\t)\n}\n\nexport default Chess\n",["50","51"],"/Users/ryanfoley/sei/projects/portfolio/src/components/Chess/pieces.js",["52","53","54","55","56","57","58"],"import { Board } from './board.js'\n\nclass Piece {\n\tconstructor(color, name, row, col) {\n\t\tthis.color = color\n\t\tthis.name = name\n\t\tthis.row = row\n\t\tthis.col = col\n\t\tthis.targets = []\n\t}\n\n\tchangePosition(row, col) {\n\t\tthis.row = row\n\t\tthis.col = col\n\t}\n\n\t// removePieceFromSquare() {\n\t// \tBoard.board[this.row][this.col].color = ''\n\t// \tBoard.board[this.row][this.col].piece = ''\n\t// \tBoard.board[this.row][this.col].empty = true\n\t// }\n\n\t// assignPieceToSquare() {\n\t// \tBoard.board[this.row][this.col].color = this.color\n\t// \tBoard.board[this.row][this.col].piece = this\n\t// \tBoard.board[this.row][this.col].empty = false\n\t// }\n\n\tremovePieceFromSquare(board) {\n\t\tboard[this.row][this.col].color = ''\n\t\tboard[this.row][this.col].piece = ''\n\t\tboard[this.row][this.col].empty = true\n\t}\n\n\tassignPieceToSquare(board) {\n\t\tboard[this.row][this.col].color = this.color\n\t\tboard[this.row][this.col].piece = this\n\t\tboard[this.row][this.col].empty = false\n\t}\n\n\tmovePiece(board, landingSquare, opponent) {\n\t\t// Remove piece from square\n\t\tthis.removePieceFromSquare(board)\n\n\t\t// If capture, remove piece from game\n\t\tif (landingSquare.piece) opponent.removePieceFromGame(landingSquare.piece)\n\n\t\t// Move piece to new square\n\t\tthis.changePosition(landingSquare.row, landingSquare.col)\n\t\tthis.assignPieceToSquare(board)\n\t}\n\n\tclearTargetSquares() {\n\t\tthis.targets = []\n\t}\n\n\tprintPiece() {\n\t\tconsole.log(this.piece)\n\t}\n}\n\nclass Pawn extends Piece {\n\tconstructor(color, piece, row, col) {\n\t\tsuper(color, piece, row, col)\n\t}\n\n\tcheckForValidMove(player, chessBoard, landingSquare) {\n\t\t// console.log(player)\n\t\t// Find all available moves\n\n\t\t// Set board\n\t\tthis.chessBoard = chessBoard\n\n\t\t// Check if move puts their king in check\n\t\tconst startingSquare = this.color === 'white' ? 6 : 1\n\t\tconst oneSquareUp = this.color === 'white' ? this.row - 1 : this.row + 1\n\t\tconst twoSquaresUp = this.color === 'white' ? this.row - 2 : this.row + 2\n\n\t\tif (\n\t\t\t// Check if landingSquare is a valid move\n\t\t\t(this.col === landingSquare.col &&\n\t\t\t\t!landingSquare.piece &&\n\t\t\t\tlandingSquare.row === oneSquareUp) ||\n\t\t\t(this.col === landingSquare.col &&\n\t\t\t\tthis.row === startingSquare &&\n\t\t\t\tlandingSquare.row === twoSquaresUp &&\n\t\t\t\t!landingSquare.piece) ||\n\t\t\t// Check for capture of opponents piece\n\t\t\t(Math.abs(this.row - landingSquare.row) === 1 &&\n\t\t\t\tMath.abs(this.col - landingSquare.col) === 1 &&\n\t\t\t\tlandingSquare.piece &&\n\t\t\t\tthis.color !== landingSquare.piece.color)\n\t\t) {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tmarkEnemySquares(board) {\n\t\t// Get targeted squares\n\t\tlet row\n\t\tif (this.color === 'white') {\n\t\t\trow = this.row > 0 ? this.row - 1 : null\n\t\t} else {\n\t\t\trow = this.row < 7 ? this.row + 1 : null\n\t\t}\n\n\t\tconst leftCol = this.col > 0 ? this.col - 1 : null\n\t\tconst rightCol = this.col < 7 ? this.col + 1 : null\n\n\t\t// Add squares to targets array\n\t\tif (row) {\n\t\t\tif (leftCol) this.targets.push(board[row][leftCol])\n\t\t\tif (rightCol) this.targets.push(board[row][rightCol])\n\t\t}\n\t}\n}\n\nclass Knight extends Piece {\n\tconstructor(color, piece, row, col) {\n\t\tsuper(color, piece, row, col)\n\t}\n\n\tcheckForValidMove(player, chessBoard, landingSquare) {\n\t\t// Set board\n\t\tthis.chessBoard = chessBoard\n\n\t\tif (\n\t\t\t(Math.abs(this.row - landingSquare.row) === 1 &&\n\t\t\t\tMath.abs(this.col - landingSquare.col) === 2 &&\n\t\t\t\tthis.color !== landingSquare.piece.color) ||\n\t\t\t(Math.abs(this.row - landingSquare.row) === 2 &&\n\t\t\t\tMath.abs(this.col - landingSquare.col) === 1 &&\n\t\t\t\tthis.color !== landingSquare.piece.color)\n\t\t) {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tmarkEnemySquares(board) {\n\t\t// Mark target squares\n\t\tfor (let row = this.row - 2; row <= this.row + 2; row++) {\n\t\t\tfor (let col = this.col - 2; col <= this.col + 2; col++) {\n\t\t\t\tif (\n\t\t\t\t\t(Math.abs(this.row - row) === 2 && Math.abs(this.col - col) === 1) ||\n\t\t\t\t\t(Math.abs(this.row - row) === 1 && Math.abs(this.col - col) === 2)\n\t\t\t\t) {\n\t\t\t\t\tif (row >= 0 && row <= 7 && col >= 0 && col <= 7) {\n\t\t\t\t\t\tthis.targets.push(board[row][col])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Bishop extends Piece {\n\tconstructor(color, piece, row, col) {\n\t\tsuper(color, piece, row, col)\n\t}\n\n\tcheckForValidMove(player, chessBoard, landingSquare) {\n\t\t// Set board\n\t\tthis.chessBoard = chessBoard\n\n\t\t// Check movement direction\n\t\tconst xDirection = landingSquare.col < this.col ? 'left' : 'right'\n\t\tconst yDirection = landingSquare.row < this.row ? 'up' : 'down'\n\t\tlet direction\n\t\tif (yDirection === 'up' && xDirection === 'left') direction = 'upLeft'\n\t\tif (yDirection === 'up' && xDirection === 'right') direction = 'upRight'\n\t\tif (yDirection === 'down' && xDirection === 'left') direction = 'downLeft'\n\t\tif (yDirection === 'down' && xDirection === 'right') direction = 'downRight'\n\n\t\t// Check if movement is diagonal\n\t\tif (\n\t\t\tMath.abs(this.row - landingSquare.row) ===\n\t\t\tMath.abs(this.col - landingSquare.col)\n\t\t) {\n\t\t\t// Check for piece in the way\n\t\t\tlet isPieceInWay = false\n\t\t\tif (direction === 'upLeft') {\n\t\t\t\tlet row = this.row - 1\n\t\t\t\tlet col = this.col - 1\n\t\t\t\tfor (; row > landingSquare.row; row--, col--) {\n\t\t\t\t\tif (this.chessBoard.board[row][col].piece) {\n\t\t\t\t\t\tisPieceInWay = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (direction === 'upRight') {\n\t\t\t\tlet row = this.row - 1\n\t\t\t\tlet col = this.col + 1\n\t\t\t\tfor (; row > landingSquare.row; row--, col++) {\n\t\t\t\t\tif (this.chessBoard.board[row][col].piece) {\n\t\t\t\t\t\tisPieceInWay = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (direction === 'downLeft') {\n\t\t\t\tlet row = this.row + 1\n\t\t\t\tlet col = this.col - 1\n\t\t\t\tfor (; row < landingSquare.row; row++, col--) {\n\t\t\t\t\tif (this.chessBoard.board[row][col].piece) {\n\t\t\t\t\t\tisPieceInWay = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (direction === 'downRight') {\n\t\t\t\tlet row = this.row + 1\n\t\t\t\tlet col = this.col + 1\n\t\t\t\tfor (; row < landingSquare.row; row++, col++) {\n\t\t\t\t\tif (this.chessBoard.board[row][col].piece) {\n\t\t\t\t\t\tisPieceInWay = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isPieceInWay && landingSquare.piece.color !== this.color) return true\n\t\t}\n\t\treturn false\n\t}\n\n\tmarkEnemySquares(board) {\n\t\t// Mark target squares\n\n\t\t// Check upLeft direction\n\t\tlet row = this.row - 1\n\t\tlet col = this.col - 1\n\t\tfor (; row >= 0 && col >= 0; row--, col--) {\n\t\t\tthis.targets.push(board[row][col])\n\t\t\tif (board[row][col].piece) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Check upRight direction\n\t\trow = this.row - 1\n\t\tcol = this.col + 1\n\t\tfor (; row >= 0 && col <= 7; row--, col++) {\n\t\t\tthis.targets.push(board[row][col])\n\t\t\tif (board[row][col].piece) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Check downLeft direction\n\t\trow = this.row + 1\n\t\tcol = this.col - 1\n\t\tfor (; row <= 7 && col >= 0; row++, col--) {\n\t\t\tthis.targets.push(board[row][col])\n\t\t\tif (board[row][col].piece) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Check upLeft direction\n\t\trow = this.row + 1\n\t\tcol = this.col + 1\n\t\tfor (; row <= 7 && col <= 7; row++, col++) {\n\t\t\tthis.targets.push(board[row][col])\n\t\t\tif (board[row][col].piece) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Rook extends Piece {\n\tconstructor(color, piece, row, col) {\n\t\tsuper(color, piece, row, col)\n\t}\n\n\tcheckForValidMove(player, chessBoard, landingSquare) {\n\t\t// Set board\n\t\tthis.chessBoard = chessBoard\n\n\t\t// Check movement direction\n\t\tlet direction\n\t\tif (landingSquare.col < this.col) {\n\t\t\tdirection = 'left'\n\t\t} else if (landingSquare.col > this.col) {\n\t\t\tdirection = 'right'\n\t\t} else if (landingSquare.row < this.row) {\n\t\t\tdirection = 'up'\n\t\t} else if (landingSquare.row > this.row) direction = 'down'\n\n\t\tlet isPieceInWay = false\n\t\tif (direction === 'left') {\n\t\t\tfor (let i = this.col - 1; i > landingSquare.col; i--) {\n\t\t\t\tif (this.chessBoard.board[this.row][i].piece) {\n\t\t\t\t\tisPieceInWay = true\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (direction === 'right') {\n\t\t\tfor (let i = this.col + 1; i > landingSquare.col; i++) {\n\t\t\t\tif (this.chessBoard.board[this.row][i].piece) {\n\t\t\t\t\tisPieceInWay = true\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (direction === 'up') {\n\t\t\tfor (let i = this.row - 1; i > landingSquare.row; i--) {\n\t\t\t\tif (this.chessBoard.board[i][this.col].piece) {\n\t\t\t\t\tisPieceInWay = true\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (direction === 'down') {\n\t\t\tfor (let i = this.row + 1; i > landingSquare.row; i++) {\n\t\t\t\tif (this.chessBoard.board[i][this.col].piece) {\n\t\t\t\t\tisPieceInWay = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!isPieceInWay && landingSquare.piece.color !== this.color) return true\n\t\treturn false\n\t}\n\n\tmarkEnemySquares(board) {\n\t\t// Mark target squares\n\n\t\t// Check left direction\n\t\tfor (let col = this.col - 1; col >= 0; col--) {\n\t\t\tthis.targets.push(board[this.row][col])\n\t\t\tif (board[this.row][col].piece) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Check right direction\n\t\tfor (let col = this.col + 1; col <= 7; col++) {\n\t\t\tthis.targets.push(board[this.row][col])\n\t\t\tif (board[this.row][col].piece) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Check up direction\n\t\tfor (let row = this.row - 1; row >= 0; row--) {\n\t\t\tthis.targets.push(board[row][this.col])\n\t\t\tif (board[row][this.col].piece) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Check down direction\n\t\tfor (let row = this.row + 1; row <= 7; row++) {\n\t\t\tthis.targets.push(board[row][this.col])\n\t\t\tif (board[row][this.col].piece) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Queen extends Piece {\n\tconstructor(color, piece, row, col) {\n\t\tsuper(color, piece, row, col)\n\t}\n\n\tcheckForValidMove(player, chessBoard, landingSquare) {\n\t\t// Set board\n\t\tthis.chessBoard = chessBoard\n\n\t\tconst checkBishopMove = () => {\n\t\t\t// Check movement direction\n\t\t\tconst xDirection = landingSquare.col < this.col ? 'left' : 'right'\n\t\t\tconst yDirection = landingSquare.row < this.row ? 'up' : 'down'\n\t\t\tlet direction\n\t\t\tif (yDirection === 'up' && xDirection === 'left') direction = 'upLeft'\n\t\t\tif (yDirection === 'up' && xDirection === 'right') direction = 'upRight'\n\t\t\tif (yDirection === 'down' && xDirection === 'left') direction = 'downLeft'\n\t\t\tif (yDirection === 'down' && xDirection === 'right')\n\t\t\t\tdirection = 'downRight'\n\n\t\t\t// Check if movement is diagonal\n\t\t\tif (\n\t\t\t\tMath.abs(this.row - landingSquare.row) ===\n\t\t\t\tMath.abs(this.col - landingSquare.col)\n\t\t\t) {\n\t\t\t\t// Check for piece in the way\n\t\t\t\tlet isPieceInWay = false\n\t\t\t\tif (direction === 'upLeft') {\n\t\t\t\t\tlet row = this.row - 1\n\t\t\t\t\tlet col = this.col - 1\n\t\t\t\t\tfor (; row > landingSquare.row; row--, col--) {\n\t\t\t\t\t\tif (this.chessBoard.board[row][col].piece) {\n\t\t\t\t\t\t\tisPieceInWay = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (direction === 'upRight') {\n\t\t\t\t\tlet row = this.row - 1\n\t\t\t\t\tlet col = this.col + 1\n\t\t\t\t\tfor (; row > landingSquare.row; row--, col++) {\n\t\t\t\t\t\tif (this.chessBoard.board[row][col].piece) {\n\t\t\t\t\t\t\tisPieceInWay = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (direction === 'downLeft') {\n\t\t\t\t\tlet row = this.row + 1\n\t\t\t\t\tlet col = this.col - 1\n\t\t\t\t\tfor (; row < landingSquare.row; row++, col--) {\n\t\t\t\t\t\tif (this.chessBoard.board[row][col].piece) {\n\t\t\t\t\t\t\tisPieceInWay = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (direction === 'downRight') {\n\t\t\t\t\tlet row = this.row + 1\n\t\t\t\t\tlet col = this.col + 1\n\t\t\t\t\tfor (; row < landingSquare.row; row++, col++) {\n\t\t\t\t\t\tif (this.chessBoard.board[row][col].piece) {\n\t\t\t\t\t\t\tisPieceInWay = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!isPieceInWay && landingSquare.piece.color !== this.color)\n\t\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\tconst checkRookMove = () => {\n\t\t\t// Check movement direction\n\t\t\tlet direction\n\t\t\tif (landingSquare.col < this.col) {\n\t\t\t\tdirection = 'left'\n\t\t\t} else if (landingSquare.col > this.col) {\n\t\t\t\tdirection = 'right'\n\t\t\t} else if (landingSquare.row < this.row) {\n\t\t\t\tdirection = 'up'\n\t\t\t} else if (landingSquare.row > this.row) direction = 'down'\n\n\t\t\tlet isPieceInWay = false\n\t\t\tif (direction === 'left') {\n\t\t\t\tfor (let i = this.col - 1; i > landingSquare.col; i--) {\n\t\t\t\t\tif (this.chessBoard.board[this.row][i].piece) {\n\t\t\t\t\t\tisPieceInWay = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (direction === 'right') {\n\t\t\t\tfor (let i = this.col + 1; i > landingSquare.col; i++) {\n\t\t\t\t\tif (this.chessBoard.board[this.row][i].piece) {\n\t\t\t\t\t\tisPieceInWay = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (direction === 'up') {\n\t\t\t\tfor (let i = this.row - 1; i > landingSquare.row; i--) {\n\t\t\t\t\tif (this.chessBoard.board[i][this.col].piece) {\n\t\t\t\t\t\tisPieceInWay = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (direction === 'down') {\n\t\t\t\tfor (let i = this.row + 1; i > landingSquare.row; i++) {\n\t\t\t\t\tif (this.chessBoard.board[i][this.col].piece) {\n\t\t\t\t\t\tisPieceInWay = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isPieceInWay && landingSquare.piece.color !== this.color) return true\n\t\t\treturn false\n\t\t}\n\t\treturn checkBishopMove() || checkRookMove()\n\t}\n\n\tmarkEnemySquares(board) {\n\t\t// Mark target squares\n\t\tconst markBishopSquares = () => {\n\t\t\t// Check upLeft direction\n\t\t\tlet row = this.row - 1\n\t\t\tlet col = this.col - 1\n\t\t\tfor (; row >= 0 && col >= 0; row--, col--) {\n\t\t\t\tthis.targets.push(board[row][col])\n\t\t\t\tif (board[row][col].piece) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check upRight direction\n\t\t\trow = this.row - 1\n\t\t\tcol = this.col + 1\n\t\t\tfor (; row >= 0 && col <= 7; row--, col++) {\n\t\t\t\tthis.targets.push(board[row][col])\n\t\t\t\tif (board[row][col].piece) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check downLeft direction\n\t\t\trow = this.row + 1\n\t\t\tcol = this.col - 1\n\t\t\tfor (; row <= 7 && col >= 0; row++, col--) {\n\t\t\t\tthis.targets.push(board[row][col])\n\t\t\t\tif (board[row][col].piece) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check upLeft direction\n\t\t\trow = this.row + 1\n\t\t\tcol = this.col + 1\n\t\t\tfor (; row <= 7 && col <= 7; row++, col++) {\n\t\t\t\tthis.targets.push(board[row][col])\n\t\t\t\tif (board[row][col].piece) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst markRookSquares = () => {\n\t\t\t// Mark target squares\n\n\t\t\t// Check left direction\n\t\t\tfor (let col = this.col - 1; col >= 0; col--) {\n\t\t\t\tthis.targets.push(board[this.row][col])\n\t\t\t\tif (board[this.row][col].piece) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check right direction\n\t\t\tfor (let col = this.col + 1; col <= 7; col++) {\n\t\t\t\tthis.targets.push(board[this.row][col])\n\t\t\t\tif (board[this.row][col].piece) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check up direction\n\t\t\tfor (let row = this.row - 1; row >= 0; row--) {\n\t\t\t\tthis.targets.push(board[row][this.col])\n\t\t\t\tif (board[row][this.col].piece) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check down direction\n\t\t\tfor (let row = this.row + 1; row <= 7; row++) {\n\t\t\t\tthis.targets.push(board[row][this.col])\n\t\t\t\tif (board[row][this.col].piece) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmarkBishopSquares()\n\t\tmarkRookSquares()\n\n\t\t// Check if king is threatened\n\t\t// this.targets.forEach((target) => {\n\t\t// \tif (target.piece.name === 'king' && target.piece.color != this.color) {\n\t\t// \t\tthis.color === 'white'\n\t\t// \t\t\t? (whitePlayer.inCheck = true)\n\t\t// \t\t\t: (blackPlayer.inCheck = true)\n\t\t// \t}\n\t\t// })\n\t}\n}\n\nclass King extends Piece {\n\tconstructor(color, piece, row, col) {\n\t\tsuper(color, piece, row, col)\n\t}\n\t// maybe remove player argument\n\tcheckForValidMove(player, chessBoard, landingSquare) {\n\t\tconst enemySquares =\n\t\t\tthis.color === 'white'\n\t\t\t\t? chessBoard.blackSquares.flat()\n\t\t\t\t: chessBoard.whiteSquares.flat()\n\n\t\tconst isEnemySquare = enemySquares.find(\n\t\t\t(square) => square === landingSquare\n\t\t)\n\n\t\t// Set board\n\t\tthis.chessBoard = chessBoard\n\n\t\tif (\n\t\t\tMath.abs(this.row - landingSquare.row) <= 1 &&\n\t\t\tMath.abs(this.col - landingSquare.col) <= 1 &&\n\t\t\tlandingSquare.color !== this.color &&\n\t\t\t!isEnemySquare\n\t\t) {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tmarkEnemySquares(board) {\n\t\t// Mark target squares\n\t\tlet row = this.row > 0 ? this.row - 1 : null\n\t\tlet col = this.col > 0 ? this.col - 1 : null\n\t\tfor (; row <= this.row + 1; row++) {\n\t\t\tfor (; col <= this.col + 1; col++) {\n\t\t\t\tif (row && col) {\n\t\t\t\t\tthis.targets.push(board[row][col])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst whitePieces = []\nconst blackPieces = []\n\n// Add pieces to whitePieces and blackPieces array\nfor (let color of ['white', 'black']) {\n\tfor (let i = 0; i < 8; i++) {\n\t\tcolor === 'white'\n\t\t\t? whitePieces.push(new Pawn(color, 'pawn', 6, i))\n\t\t\t: blackPieces.push(new Pawn(color, 'pawn', 1, i))\n\t}\n}\n\nwhitePieces.push(new Knight('white', 'knight', 7, 1))\nwhitePieces.push(new Knight('white', 'knight', 7, 6))\nwhitePieces.push(new Bishop('white', 'bishop', 7, 2))\nwhitePieces.push(new Bishop('white', 'bishop', 7, 5))\nwhitePieces.push(new Rook('white', 'rook', 7, 0))\nwhitePieces.push(new Rook('white', 'rook', 7, 7))\nwhitePieces.push(new Queen('white', 'queen', 7, 3))\nwhitePieces.push(new King('white', 'king', 7, 4))\n\nblackPieces.push(new Knight('black', 'knight', 0, 1))\nblackPieces.push(new Knight('black', 'knight', 0, 6))\nblackPieces.push(new Bishop('black', 'bishop', 0, 2))\nblackPieces.push(new Bishop('black', 'bishop', 0, 5))\nblackPieces.push(new Rook('black', 'rook', 0, 0))\nblackPieces.push(new Rook('black', 'rook', 0, 7))\nblackPieces.push(new Queen('black', 'queen', 0, 3))\nblackPieces.push(new King('black', 'king', 0, 4))\n\n// Assign pieces to squares on board\nconst placePiecesOnBoard = ({ board }) => {\n\twhitePieces.forEach((piece) => {\n\t\tpiece.assignPieceToSquare(board)\n\t})\n\n\tblackPieces.forEach((piece) => {\n\t\tpiece.assignPieceToSquare(board)\n\t})\n}\n\nexport { placePiecesOnBoard, whitePieces, blackPieces }\n","/Users/ryanfoley/sei/projects/portfolio/src/components/Chess/players.js",[],"/Users/ryanfoley/sei/projects/portfolio/src/components/Chess/board.js",[],"/Users/ryanfoley/sei/projects/portfolio/src/components/Nav/Nav.js",[],"/Users/ryanfoley/sei/projects/portfolio/src/components/About/About.js",[],"/Users/ryanfoley/sei/projects/portfolio/src/components/Projects/Projects.js",[],{"ruleId":"59","replacedBy":"60"},{"ruleId":"61","replacedBy":"62"},{"ruleId":"63","severity":1,"message":"64","line":10,"column":6,"nodeType":"65","messageId":"66","endLine":10,"endColumn":20},{"ruleId":"67","severity":1,"message":"68","line":184,"column":4,"nodeType":"69","endLine":184,"endColumn":27},{"ruleId":"59","replacedBy":"70"},{"ruleId":"61","replacedBy":"71"},{"ruleId":"63","severity":1,"message":"72","line":1,"column":10,"nodeType":"65","messageId":"66","endLine":1,"endColumn":15},{"ruleId":"73","severity":1,"message":"74","line":63,"column":2,"nodeType":"75","messageId":"76","endLine":65,"endColumn":3},{"ruleId":"73","severity":1,"message":"74","line":120,"column":2,"nodeType":"75","messageId":"76","endLine":122,"endColumn":3},{"ruleId":"73","severity":1,"message":"74","line":159,"column":2,"nodeType":"75","messageId":"76","endLine":161,"endColumn":3},{"ruleId":"73","severity":1,"message":"74","line":267,"column":2,"nodeType":"75","messageId":"76","endLine":269,"endColumn":3},{"ruleId":"73","severity":1,"message":"74","line":353,"column":2,"nodeType":"75","messageId":"76","endLine":355,"endColumn":3},{"ruleId":"73","severity":1,"message":"74","line":555,"column":2,"nodeType":"75","messageId":"76","endLine":557,"endColumn":3},"no-native-reassign",["77"],"no-negated-in-lhs",["78"],"no-unused-vars","'squareSelected' is assigned a value but never used.","Identifier","unusedVar","jsx-a11y/heading-has-content","Headings must have content and the content must be accessible by a screen reader.","JSXOpeningElement",["77"],["78"],"'Board' is defined but never used.","no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","no-global-assign","no-unsafe-negation"]